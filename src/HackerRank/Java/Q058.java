package HackerRank.Java;

import java.util.*;

/*
Java>Advanced>Java Visitor Pattern
Note: In this problem you must NOT generate any output on your own.
Any such solution will be considered as being against the rules
and its author will be disqualified.
The output of your solution must be generated by the uneditable
code provided for you in the solution template.

An important concept in Object-Oriented Programming is the open/closed principle,
which means writing code that is open to extension but closed to modification.
In other words, new functionality should be added by writing an extension
for the existing code rather than modifying it and potentially breaking
other code that uses it. This challenge simulates
a real-life problem where the open/closed principle can and should be applied.

A Tree class implementing a rooted tree is provided in the editor.
It has the following publicly available methods:

getValue(): Returns the value stored in the node.
getColor(): Returns the color of the node.
getDepth(): Returns the depth of the node. Recall that the depth of a node
is the number of edges between the node
and the tree's root, so the tree's root has depth 0
and each descendant node's depth is equal to the depth of its parent node +1.

In this challenge, we treat the internal implementation of the tree
as being closed to modification, so we cannot directly modify it;
however, as with real-world situations, the implementation is written in such a way
that it allows external classes to extend and build upon its functionality.
More specifically, it allows objects of the TreeVis class (a Visitor Design Pattern)
to visit the tree and traverse the tree structure via the accept method.

There are two parts to this challenge.
---------------------------------------------------------
Part I: Implement Three Different Visitors
Each class has three methods you must write implementations for:

getResult(): Return an integer denoting the result,
  which is different for each class:

The SumInLeavesVisitor implementation must return the sum of the values in the tree's leaves only.

The ProductRedNodesVisitor implementation must return
the product of values stored in all red nodes,
including leaves, computed modulo 10^9+7.
Note that the product of zero values is equal to 1.

The FancyVisitor implementation must return
the absolute difference between the sum of values stored in the tree's
non-leaf nodes at even depth and the sum of values stored in the tree's green leaf nodes.
Recall that zero is an even number.

visitNode(TreeNode node): Implement the logic responsible for visiting
the tree's non-leaf nodes such that the
getResult method returns the correct result for the implementing class' visitor.

visitLeaf(TreeLeaf leaf): Implement the logic responsible
for visiting the tree's leaf nodes such that the
getResult method returns the correct result for the implementing class' visitor.
--------------------------------------------------------------------------------
Part II: Read and Build the Tree
Read the n-node tree, where each node is numbered from 1 to n.
The tree is given as a list of node values (x_1,x_2,...x_n),
a list of node colors (c_1,c_2,...,c_n), and a list of edges.
Construct this tree as an instance of the Tree class.
The tree is always rooted at node number 1.

Your implementations of the three visitor classes will be tested
on the tree you built from the given input.

Input Format

The first line contains a single integer, n, denoting the number of nodes in the tree.
The second line contains n space-separated integers
describing the respective values of x_1,x_2,...,x_n.
The third line contains n space-separated binary integers
describing the respective values of c_1,c_2,...,c_n.
Each c_i denotes the color of the i. node, where 0 denotes red and 1 denotes green.
Each of the n-1 subsequent lines contains
two space-separated integers, u_i and v_i , describing an edge between nodes u_i and v_i.
Sample Input

5
4 7 2 5 12
0 1 0 0 1
1 2
1 3
3 4
3 5
Sample Output

24
40
15

                    [x_1=4,r]
                    /     \
                   /       \
              [x_2=7,g]   [x_3=2,r]
                          /    \
                         /      \
                     [x_4=5,r]  [x_5=12,g]

 */
enum Color {
    RED, GREEN
}
abstract class Tree {

    private int value;
    private Color color;
    private int depth;

    public Tree(int value, Color color, int depth) {
        this.value = value;
        this.color = color;
        this.depth = depth;
    }

    public int getValue() {
        return value;
    }

    public Color getColor() {
        return color;
    }

    public int getDepth() {
        return depth;
    }

    public abstract void accept(TreeVis visitor);
}
class TreeNode extends Tree {

    private ArrayList<Tree> children = new ArrayList<>();

    public TreeNode(int value, Color color, int depth) {
        super(value, color, depth);
    }

    public void accept(TreeVis visitor) {
        visitor.visitNode(this);

        for (Tree child : children) {
            child.accept(visitor);
        }
    }
    public void addChild(Tree child) {
        children.add(child);
    }
}
class TreeLeaf extends Tree {

    public TreeLeaf(int value, Color color, int depth) {
        super(value, color, depth);
    }

    public void accept(TreeVis visitor) {
        visitor.visitLeaf(this);
    }
}

abstract class TreeVis
{
    public abstract int getResult();
    public abstract void visitNode(TreeNode node);
    public abstract void visitLeaf(TreeLeaf leaf);

}
class SumInLeavesVisitor extends TreeVis {
    private int result =0;
    public int getResult() {
       return result;
    }

    public void visitNode(TreeNode node) {
        //implement this
    }

    public void visitLeaf(TreeLeaf leaf) {
        result+=leaf.getValue();
    }
}
class ProductOfRedNodesVisitor extends TreeVis {
    private long result =1;
    private final int M=1000000007;

    public int getResult() {
       return (int) result;
    }

    public void visitNode(TreeNode node) {
        multiplyNode(node);
    }
    private void multiplyNode(Tree node){
        if (node.getColor().equals(Color.RED)){
            if (node.getValue()!=0) {
               result = (result * node.getValue()) % M;
            }
        }
    }
    public void visitLeaf(TreeLeaf leaf) {
        multiplyNode(leaf);
    }
}
class FancyVisitor extends TreeVis {
    private int evenDepthNonLeavesSum = 0;
    private int greenLeavesSum = 0;

    public int getResult() {
        return Math.abs(evenDepthNonLeavesSum - greenLeavesSum);
    }

    public void visitNode(TreeNode node) {
        if(node.getDepth() % 2 == 0) {
            evenDepthNonLeavesSum += node.getValue();
        }
    }

    public void visitLeaf(TreeLeaf leaf) {
        if(leaf.getColor().equals(Color.GREEN)) {
            greenLeavesSum += leaf.getValue();
        }
    }
}

public class Q058 {
    static Map<Integer, Tree> tree = new HashMap<>();
    public static Tree solve() {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Map<Integer, Object[]> nodeAtts = new HashMap<Integer, Object[]>();
        for (int i = 0; i < n; i++)
            nodeAtts.put(i + 1, new Object[]{sc.nextInt(), null});
        for (int i = 0; i < n; i++)
            nodeAtts.get(i + 1)[1] = sc.nextInt() == 0 ? Color.RED : Color.GREEN;
        Map<Integer, ArrayList<Integer>> edges = new HashMap<Integer, ArrayList<Integer>>();
        for (int i = 1; i <= n; i++)
            edges.put(i, new ArrayList<Integer>());
        for (int i = 1; i < n; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            edges.get(u).add(v);
            edges.get(v).add(u);
        }
        Tree root = new TreeNode((Integer) nodeAtts.get(1)[0], (Color) nodeAtts.get(1)[1], 0);
        tree.put(1, root);
        DFS(n, edges, nodeAtts);
        return tree.get(1);
    }
    private static void DFS(int n, Map<Integer, ArrayList<Integer>> edges, Map<Integer, Object[]> nodeAtts) {
        boolean[] visited = new boolean[n + 1];
        TreeNode parent = (TreeNode) tree.get(1);
        DFSUtil(parent, 1, visited, edges, nodeAtts);
    }
    private static void DFSUtil(TreeNode parent, int v, boolean[] visited, Map<Integer, ArrayList<Integer>> edges, Map<Integer, Object[]> nodeAtts) {
        visited[v] = true;
        if (edges.get(v).size() == 1 && v != 1) {
            TreeLeaf treeLeaf = new TreeLeaf((Integer) nodeAtts.get(v)[0], (Color) nodeAtts.get(v)[1], parent.getDepth() + 1);
            parent.addChild(treeLeaf);
            tree.put(v, treeLeaf);
            return;
        }
        TreeNode treeNode;
        if (v != 1) {
            treeNode = new TreeNode((Integer) nodeAtts.get(v)[0], (Color) nodeAtts.get(v)[1], parent.getDepth() + 1);
            parent.addChild(treeNode);
            tree.put(v, treeNode);
        } else
            treeNode = (TreeNode) tree.get(1);
        Iterator<Integer> iterator = edges.get(v).iterator();
        while (iterator.hasNext()) {
            int n = iterator.next();
            if (!visited[n]) {
                DFSUtil(treeNode, n, visited, edges, nodeAtts);
            }
        }
    }
    static int values[];
    static Color colors[];
    static Map<Integer, Set<Integer>> nodesMap = new HashMap<>();

    public static Tree solve3(){
        Scanner in=new Scanner(System.in);
        int nnodes=in.nextInt();
        values= new int[nnodes];
        for(int i=0;i<nnodes;i++)values[i]=in.nextInt();
        colors = new Color[nnodes];
        for(int i=0;i<nnodes;i++)colors[i]=(in.nextInt()==0)?Color.RED:Color.GREEN;
        Tree rootNode;
        if(nnodes==1){
            rootNode=new TreeLeaf(values[0],colors[0],0);
        }else{
            rootNode=new TreeNode(values[0],colors[0],0);
            for(int i=0;i<(nnodes-1);i++) {
                int u = in.nextInt();
                int v = in.nextInt();
                Set<Integer> uEdges = nodesMap.get(u);
                if(uEdges==null)uEdges = new HashSet<>();
                uEdges.add(v);
                nodesMap.put(u, uEdges);
                Set<Integer> vEdges = nodesMap.get(v);
                if(vEdges==null)vEdges = new HashSet<>();
                vEdges.add(u);
                nodesMap.put(v, vEdges);
            }
            for(int nodeid:nodesMap.get(1)){
                nodesMap.get(nodeid).remove(1);
                createEdge(rootNode, nodeid);
            }
        }
        return rootNode;
    }

    private static void createEdge(Tree parent,int nodeid){
        Set<Integer> nodeEdges = nodesMap.get(nodeid);
        boolean hasChild = nodeEdges!=null && !nodeEdges.isEmpty();
        if(hasChild){
            TreeNode node = new TreeNode(values[nodeid-1],colors[nodeid-1],parent.getDepth()+1);
            ((TreeNode)parent).addChild(node);
            for(int neighborid:nodeEdges){
                nodesMap.get(neighborid).remove(nodeid);
                createEdge(node, neighborid);
            }
        }else{
            TreeLeaf leaf = new TreeLeaf(values[nodeid-1],colors[nodeid-1],parent.getDepth()+1);
            ((TreeNode)parent).addChild(leaf);
        }
    }
    public static Tree solve2() {
        //read the tree from STDIN and return its root as a return value of this function
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int x[] = new int[n+1];
        Color c[] = new Color[n+1];
        int u[] = new int[n];
        int v[] = new int[n];
        for (int i = 1; i < n+1; i++) {
            x[i] = scan.nextInt();
        }
        for (int i = 1; i < n+1; i++) {
            c[i] = scan.nextByte()==0?Color.RED:Color.GREEN;
        }
        for (int i = 1; i < n; i++) {
            u[i] = scan.nextInt();
            v[i] = scan.nextInt();
        }
        Tree treeNodes[] = new Tree[n+1];
        int depths[] = new int[n+1];
        depths[1] = 0;
        treeNodes[1] = new TreeNode(x[1],c[1],depths[1]);
        for (int i = 1; i < n; i++) {
            depths[v[i]]=depths[u[i]]+1;
        }

        Tree t= null;
        for (int i=2;i<n+1;i++){
            if (hasChild(u,i)){
                t=new TreeNode(x[i],c[i],treeNodes[getParentIndex(i,u,v)].getDepth()+1);
            }else{
                t=new TreeLeaf(x[i],c[i],treeNodes[getParentIndex(i,u,v)].getDepth()+1);
            }
            treeNodes[i] = t;
            for (int k=1;k<v.length;k++){
                if (v[k]==i){
                    ((TreeNode)treeNodes[u[k]]).addChild(t);
                    break;
                }
            }
        }
        return treeNodes[1];
    }
    public static int getParentIndex(int val,int u[], int v[]){
        for(int i=1;i<v.length+1;i++){
            if (v[i]==val){
                return u[i];
            }
        }
        return 0;
    }
    public static boolean hasChild(int u[], int el){
        boolean isHasChild = false;
        for (int w:u){
            if (w==el) return true;
        }
        return isHasChild;
    }

    public static void main(String[] args) {
        Tree root = solve();
        SumInLeavesVisitor vis1 = new SumInLeavesVisitor();
        ProductOfRedNodesVisitor vis2 = new ProductOfRedNodesVisitor();
        FancyVisitor vis3 = new FancyVisitor();

        root.accept(vis1);
        root.accept(vis2);
        root.accept(vis3);

        int res1 = vis1.getResult();
        int res2 = vis2.getResult();
        int res3 = vis3.getResult();

        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
    }
}
